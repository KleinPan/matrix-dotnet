using Refit;
using Microsoft.Extensions.Http.Logging;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Collections.Immutable;

namespace matrix_dotnet;

using StateDict = ImmutableDictionary<StateKey, IMatrixApi.EventContent>;
public record StateKey(string type, string state_key);

/// <summary>
/// The main client class for interacting with Matrix. Most operations
/// require you to login first, see <see cref="MatrixClient.PasswordLogin"/>
/// and <see cref="MatrixClient.TokenLogin"/>
/// </summary>
public class MatrixClient {
	/// <summary> The base URL of the homeserver </summary>
	public Uri Homeserver { get; private set; }
	/// <summary> The underlying API class used to make API calls directly </summary>
	public IMatrixApi Api { get; private set; }

	public string? AccessToken { get; private set; }
	public string? RefreshToken { get; private set; }

	/// <summary> <c>user_id</c> of the currently logged-in user. </summary>
	public string? UserId { get; private set; }
	/// <summary> This client's <c>device_id</c> either generated by the backend
	/// or supplied. Subsequent logins from the same client and device should reuse it.
	/// <seealso href="https://spec.matrix.org/v1.11/client-server-api/#relationship-between-access-tokens-and-devices"/> </summary>
	public string? DeviceId { get; private set; }
	/// <summary> The time when the access token expires. If it is
	/// expired and a <c>refresh_token</c> is available, reauth will
	/// happen automatically, otherwise logging in manually will be required. </summary>
	public DateTime? ExpiresAt { get; private set; }
	/// <summary> Is true when the client is logged in, but its access token is expired </summary>
	public bool Expired {
		get => AccessToken is not null && ExpiresAt is not null && ExpiresAt < DateTime.Now;
	}

	public ILogger? Logger;

	/// <summary>Indicates whether this client is currently logged in.
	/// This status is kept even if the access token is expired, as automatic
	/// relogin is usually possible. </summary>
	public bool LoggedIn {
		get => AccessToken is not null;
	}

	private async Task<string> GetAccessToken(HttpRequestMessage request, CancellationToken ct) {
		if (!LoggedIn) throw new LoginRequiredException();
		if (Expired) await Refresh();
		return AccessToken!;
	}

	private RefitSettings RefitSettings;

	private async Task<Exception?> ExceptionFactory(HttpResponseMessage response) {
		if (response.IsSuccessStatusCode) return null;

		var errorResponse = JsonSerializer.Deserialize<IMatrixApi.ErrorResponse>(await response.Content.ReadAsStringAsync());
		if (errorResponse is not null) {
			if (errorResponse.errcode == "M_UNKNOWN_TOKEN") {
				if (errorResponse.soft_logout is not null && errorResponse.soft_logout!.Value) {
					await Refresh();
					return new Retry.RetryException();
				} else {
					AccessToken = null;
					RefreshToken = null;
					ExpiresAt = null;
					return new LoginRequiredException();
				}
			}

			return new MatrixApiError(errorResponse.errcode, errorResponse.error, response, null);
		}

		return await ApiException.Create(
			response.RequestMessage!,
			response.RequestMessage!.Method,
			response,
			RefitSettings
		);
	}

	private string GenerateTransactionId() {
		return Guid.NewGuid().ToString();
	}

	public MatrixClient(LoginData loginData, ILogger? logger = null) : this(loginData.Homeserver, logger) {
		Homeserver = loginData.Homeserver;
		AccessToken = loginData.AccessToken;
		RefreshToken = loginData.RefreshToken;
		UserId = loginData.UserId;
		DeviceId = loginData.DeviceId;
		ExpiresAt = loginData.ExpiresAt;
	}

	public MatrixClient(string homeserver, ILogger? logger = null) : this(new Uri(homeserver), logger) { }

	public MatrixClient(Uri homeserver, ILogger? logger = null) {
		Homeserver = homeserver;
		Logger = logger;

		HttpClient client;
		if (Logger is not null) {
			client = new HttpClient(new HttpLoggingHandler(Logger, new AuthenticatedHttpClientHandler(GetAccessToken)));
		} else {
			client = new HttpClient(new AuthenticatedHttpClientHandler(GetAccessToken));
		}
		client.BaseAddress = Homeserver;

		RefitSettings = new RefitSettings {
			ExceptionFactory = ExceptionFactory,
			AuthorizationHeaderValueGetter = GetAccessToken,
			// ContentSerializer = new NewtonsoftJsonContentSerializer()
			ContentSerializer = new SystemTextJsonContentSerializer(new JsonSerializerOptions {
				// The ObjectToInferredTypesConverter is broken and cannot be used. See https://github.com/reactiveui/refit/issues/1763
				PropertyNameCaseInsensitive = true,
				PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
				Converters = {
					new PolymorphicNonFirstJsonConverterFactory(),
					new PolymorphicPropertyJsonConverterFactory(),
					new MXCConverter(), // It is a bummer that C# doesn't have an interface for loading structs from strings
					new JsonStringEnumConverter()
				}
			})
		};

		Api = RestService.For<IMatrixApi>(client, RefitSettings);
	}

	public LoginData ToLoginData() {
		return new LoginData(Homeserver, AccessToken, RefreshToken, UserId, DeviceId, ExpiresAt);
	}

	private void UpdateExpiresAt(int? expiresInMs) {
		if (expiresInMs is null) ExpiresAt = null;
		else ExpiresAt = DateTime.Now.AddMilliseconds((double)expiresInMs);
	}

	private async Task Login(IMatrixApi.LoginRequest request) {
		var response = await Api.Login(request);

		AccessToken = response.access_token;
		RefreshToken = response.refresh_token;
		UserId = response.user_id;
		DeviceId = response.device_id;
		UpdateExpiresAt(response.expires_in_ms);
	}

	/// <summary> Login using a username and a password </summary>
	/// <param name="deviceId">see <see cref="DeviceId"/>.</param>
	public async Task PasswordLogin(string username, string password, string? initialDeviceDisplayName = null, string? deviceId = null)
		=> await PasswordLogin(new IMatrixApi.UserIdentifier(username), password, initialDeviceDisplayName, deviceId);

	/// <summary> Login using an <see cref="IMatrixApi.Identifier"/> and a password </summary>
	/// <param name="deviceId">See <see cref="DeviceId"/>.</param>
	public async Task PasswordLogin(IMatrixApi.Identifier identifier, string password, string? initialDeviceDisplayName = null, string? deviceId = null) {
		await Login(new IMatrixApi.PasswordLoginRequest(identifier, password, initialDeviceDisplayName, deviceId));
	}

	/// <summary> Login using a token </summary>
	/// <param name="deviceId">See <see cref="DeviceId"/>.</param>
	public async Task TokenLogin(string token, string? initialDeviceDisplayName = null, string? deviceId = null) {
		await Login(new IMatrixApi.TokenLoginRequest(token, initialDeviceDisplayName, deviceId));
	}

	/// <summary> Refresh the access token using a refresh token </summary>
	public async Task Refresh() {
		if (RefreshToken is null) throw new LoginRequiredException();
		var response = await Api.Refresh(new IMatrixApi.RefreshRequest(RefreshToken));

		AccessToken = response.access_token;
		RefreshToken = response.refresh_token;
		UpdateExpiresAt(response.expires_in_ms);
	}

	/// <summary> Get joined rooms. <see href="https://spec.matrix.org/v1.11/client-server-api/#get_matrixclientv3joined_rooms"/> </summary>
	public async Task<string[]> GetJoinedRooms() {
		var response = await Retry.RetryAsync(async () => await Api.GetJoinedRooms());

		return response.joined_rooms;
	}

	/// <summary> Send a <c>m.room.message</c> event to a room. </summary>
	/// <returns> The <c>event_id</c> of the sent message </returns>
	public async Task<string> SendMessage<TMessage>(string roomId, TMessage message) where TMessage : IMatrixApi.Message {
		var response = await Retry.RetryAsync(async () => await Api.SendEvent(roomId, "m.room.message", GenerateTransactionId(), message));

		return response.event_id;
	}

	/// <summary> Send a basic <c>m.text</c> message to a room. </summary>
	/// <returns> The <c>event_id</c> of the sent message </returns>
	public async Task<string> SendTextMessage(string roomId, string body) => await SendMessage(roomId, new IMatrixApi.TextMessage(body));

	public record EventWithState(
		IMatrixApi.Event Event,
		StateDict State
	) {
		public IMatrixApi.RoomMember? GetSender() {
			if (Event.sender is null || !State.TryGetValue(new StateKey("m.room.member", Event.sender), out var member)) return null;
			return (IMatrixApi.RoomMember?)member;
		}
	};

	public static EventWithState[] Resolve(IEnumerable<IMatrixApi.Event> events, StateDict? stateDict = null, bool rewind = false) {
		if (stateDict is null) stateDict = StateDict.Empty;
		List<EventWithState> list = new();
		foreach (var ev in events) {
			if (ev.IsState) {
				var key = new StateKey(ev.type, ev.state_key!);
				if (rewind) {
					if (ev is not IMatrixApi.ClientEvent clientEvent) throw new InvalidOperationException("Cannot backwards resolve with stripped state");
					if (clientEvent.unsigned is null || clientEvent.unsigned.prev_content is null) stateDict = stateDict.Remove(key);
					else stateDict = stateDict.SetItem(key, clientEvent.unsigned.prev_content);
				} else {
					stateDict = stateDict.SetItem(key, ev.content!);
				}
			}

			list.Add(new EventWithState(
				ev,
				stateDict
			));
		}
		return list.ToArray();
	}

	public StateDict? PresenceState { get; private set; }

	public Dictionary<string, StateDict> InvitiedState { get; private set; } = new();
	public Dictionary<string, StateDict> KnockState { get; private set; } = new();
	private record TimelinePoint(
		EventWithState? Event,
		string? From,
		string? To
	) {
		public bool IsHole => Event is null;
	};

	private class TimelineEvent : ITimelineEvent {
		public EventWithState Event { get; private set; }
		private MatrixClient Client;
		private string RoomId;

		private LinkedListNode<TimelinePoint> Node;
		public TimelineEvent(LinkedListNode<TimelinePoint> node, MatrixClient client, string roomId) {
			if (node.Value.Event is null) throw new ArgumentNullException("TimelineEvent instantiated with hole node");
			if (node.List is null) throw new ArgumentNullException("TimelineEvent instantiated with orphan node");
			Event = node.Value.Event;
			Node = node;
			Client = client;
			RoomId = roomId;
		}

		public async Task<ITimelineEvent?> Next() {
			if (Node.Next is null) return null;
			if (Node.Next.Value.Event is not null) return new TimelineEvent(Node.Next, Client, RoomId);

			var hole = Node.Next.Value;
			var response = await Retry.RetryAsync(async () => await Client.Api.GetRoomMessages(RoomId, IMatrixApi.Dir.f, from: hole.From, to: hole.To));


			var state = Event.State;
			if (response.state is not null)
				state = Resolve(response.state, state).LastOrDefault()?.State;

			var newMessages = Resolve(response.chunk, state);

			Node.List!.Remove(Node.Next);

			if (response.end is not null)
				Node.List.AddAfter(Node, new TimelinePoint(null, response.end, hole.To));

			foreach (var message in newMessages.Reverse()) {
				Node.List.AddAfter(Node, new TimelinePoint(message, null, null));
			}

			if (newMessages.Count() == 0) return null;

			return new TimelineEvent(Node.Next, Client, RoomId);
		}

		public async Task<ITimelineEvent?> Previous() {
			if (Node.Previous is null) return null;
			if (Node.Previous.Value.Event is not null) return new TimelineEvent(Node.Previous, Client, RoomId);

			var hole = Node.Previous.Value;
			var response = await Retry.RetryAsync(async () => await Client.Api.GetRoomMessages(RoomId, IMatrixApi.Dir.b, from: hole.To, to: hole.From));

			var state = Event.State;
			if (response.state is not null)
				state = Resolve(response.state, state).LastOrDefault()?.State;

			var newMessages = Resolve(response.chunk, state, rewind: true);

			Node.List!.Remove(Node.Previous);

			if (response.end is not null)
				Node.List.AddBefore(Node, new TimelinePoint(null, hole.From, response.end));

			foreach (var message in newMessages.Reverse()) {
				Node.List.AddBefore(Node, new TimelinePoint(message, null, null));
			}

			if (newMessages.Count() == 0) return null;

			return new TimelineEvent(Node.Previous, Client, RoomId);
		}

	};
	public interface ITimelineEvent {
		public EventWithState Event { get; }
		public Task<ITimelineEvent?> Next();
		public Task<ITimelineEvent?> Previous();
		public async IAsyncEnumerable<ITimelineEvent> EnumerateForward() {
			ITimelineEvent? current = this;
			do {
				yield return current;
				current = await current.Next();
			} while (current is not null);
		}
		public async IAsyncEnumerable<ITimelineEvent> EnumerateBackward() {
			ITimelineEvent? current = this;
			do {
				yield return current;
				current = await current.Previous();
			} while (current is not null);
		}
	}

	public class Timeline {
		// TODO: lock linked list
		private LinkedList<TimelinePoint> EventList = new();

		private MatrixClient Client;
		private string RoomId;

		public ITimelineEvent? First {
			get {
				LinkedListNode<TimelinePoint>? node = EventList.First;
				if (node is null) return null;
				while (node.Value.Event is null) {
					node = node.Next;
					if (node is null) throw new Exception("Timeline is only holes. This should not happen.");
				}
				return new TimelineEvent(node, Client, RoomId);
			}
		}

		public ITimelineEvent? Last {
			get {
				LinkedListNode<TimelinePoint>? node = EventList.Last;
				if (node is null) return null;
				while (node.Value.Event is null) {
					node = node.Previous;
					if (node is null) throw new Exception("Timeline is only holes. This should not happen.");
				}
				return new TimelineEvent(node, Client, RoomId);
			}
		}

		public void Sync(IMatrixApi.Timeline timeline, StateDict? state, bool isGapped) {
			if (isGapped) {
				if (EventList.Last is not null && EventList.Last.Value.IsHole) {
					EventList.Last.Value = new TimelinePoint(null, EventList.Last.Value.From, timeline.prev_batch);
				} else {
					EventList.AddLast(new TimelinePoint(null, null, timeline.prev_batch));
				}
			}

			var resolvedEvents = MatrixClient.Resolve(timeline.events, state);

			foreach (var ev in resolvedEvents) {
				EventList.AddLast(new TimelinePoint(ev, null, null));
			}
		}

		public Timeline(MatrixClient client, string roomId) {
			Client = client;
			RoomId = roomId;
		}

	}

	public record JoinedRoom(
		StateDict account_data,
		StateDict ephemeral,
		StateDict state,
		IMatrixApi.RoomSummary summary,
		Timeline timeline,
		IMatrixApi.UnreadNotificationCounts unread_notifications,
		Dictionary<string, IMatrixApi.UnreadNotificationCounts> unread_thread_notifications
	);
	public Dictionary<string, JoinedRoom> JoinedRooms { get; private set; } = new();

	public string? NextBatch { get; private set; }

	private async Task SyncUnsafe(int timeout) {
		var response = await Retry.RetryAsync(async () => await Api.Sync(timeout: timeout, since: NextBatch));

		string original_batch = NextBatch;
		NextBatch = response.next_batch;

		if (response.presence is not null)
			PresenceState = Resolve(response.presence.events, PresenceState).Last().State;

		if (response.rooms is not null) {
			if (response.rooms.invite is not null)
				foreach (var invitedRoom in response.rooms.invite) {
					StateDict? state = null;
					InvitiedState.TryGetValue(invitedRoom.Key, out state);
					StateDict? resolvedState = Resolve(invitedRoom.Value.invite_state.events, state).LastOrDefault()?.State;
					if (resolvedState is not null)
						InvitiedState[invitedRoom.Key] = resolvedState;
				}
			if (response.rooms.knock is not null)
				foreach (var knockedRoom in response.rooms.knock) {
					StateDict? state = null;
					KnockState.TryGetValue(knockedRoom.Key, out state);
					StateDict? resolvedState = Resolve(knockedRoom.Value.knock_state.events, state).LastOrDefault()?.State;
					if (resolvedState is not null)
						KnockState[knockedRoom.Key] = resolvedState;
				}
			if (response.rooms.join is not null)
				foreach (var joinedRoom in response.rooms.join) {
					string id = joinedRoom.Key;
					var roomResponse = joinedRoom.Value;
					JoinedRoom? room = null;
					JoinedRooms.TryGetValue(id, out room);

					StateDict? account_data = Resolve(roomResponse.account_data.events, room?.account_data).LastOrDefault()?.State;
					StateDict? ephemeral = Resolve(roomResponse.ephemeral.events, room?.ephemeral).LastOrDefault()?.State;
					StateDict? state = Resolve(roomResponse.state.events, room?.state).LastOrDefault()?.State;
					IMatrixApi.RoomSummary summary = roomResponse.summary;
					Timeline timeline = room?.timeline ?? new Timeline(this, id);
					timeline.Sync(roomResponse.timeline, state, roomResponse.timeline.prev_batch != original_batch);
					state = timeline.Last?.Event.State;
					IMatrixApi.UnreadNotificationCounts unread_notifications = roomResponse.unread_notifications;
					Dictionary<string, IMatrixApi.UnreadNotificationCounts> unread_thread_notifications = room?.unread_thread_notifications ?? new();
					if (roomResponse.unread_thread_notifications is not null)
						foreach (var kv in roomResponse.unread_thread_notifications) unread_thread_notifications[kv.Key] = kv.Value;

					JoinedRooms[id] = new JoinedRoom(
						account_data ?? StateDict.Empty,
						ephemeral ?? StateDict.Empty,
						state ?? StateDict.Empty,
						summary,
						timeline,
						unread_notifications,
						unread_thread_notifications
					);
				}
			// TODO: left rooms
		}

	}

	private bool Syncing = false;
	private object SyncLock = new();

	public async Task Sync(int timeout = 0) {
		lock (SyncLock) {
			if (Syncing) {
				// Another sync is happening, return after it is done.
				while (Syncing) Monitor.Wait(SyncLock);
				return;
			} else {
				Syncing = true;
			}
		}

		await SyncUnsafe(timeout);

		lock (SyncLock) {
			Syncing = false;
		}

	}

	/// <summary> Can be serialized to JSON for persistence of login information between program runs. </summary>
	public record struct LoginData(
		Uri Homeserver,
		string? AccessToken,
		string? RefreshToken,
		string? UserId,
		string? DeviceId,
		DateTime? ExpiresAt
	);
}
